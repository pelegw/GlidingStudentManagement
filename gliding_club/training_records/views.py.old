# training_records/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.views.generic import ListView, DetailView, CreateView, UpdateView
from django.urls import reverse_lazy
from django.utils import timezone
from django.contrib import messages
from django.http import HttpResponse, FileResponse, HttpResponseForbidden
from django.db.models import Q
from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.forms import PasswordChangeForm
from django.db.models import Sum
import os 
from .models import TrainingRecord, TrainingTopic, Glider, User, Exercise
from .forms import TrainingRecordForm, SignOffForm, ProfileUpdateForm, PasswordChangeRequiredForm
from django.db import transaction
import logging
logger = logging.getLogger(__name__)
from django.core.files.storage import default_storage
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from io import StringIO, BytesIO
import csv
from django.template.loader import render_to_string
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, landscape
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch


class StudentRequiredMixin(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.is_authenticated and self.request.user.is_student()

class InstructorRequiredMixin(UserPassesTestMixin):
    def test_func(self):
        return self.request.user.is_authenticated and self.request.user.is_instructor()

# Dashboard views
@login_required
def dashboard(request):
    """Main dashboard that redirects to the appropriate view based on user type"""
    if request.user.is_instructor():
        return redirect('instructor_dashboard')
    elif request.user.is_student():
        return redirect('student_dashboard')
    else:
        return redirect('admin:index')  # Fallback to admin

# Update in training_records/views.py

@login_required
def student_dashboard(request):
    """Dashboard view for students"""
    if not request.user.is_student():
        return HttpResponseForbidden("Students only")
    
    # Get student's training records
    training_records = TrainingRecord.objects.filter(student=request.user).order_by('-date')
    
    # Calculate stats
    total_flights = training_records.count()
    solo_flights_count = training_records.filter(is_solo=True).count()
    signed_off_count = training_records.filter(signed_off=True).count()
    pending_records = training_records.filter(signed_off=False)
    
    # Calculate total flight time
    total_duration = training_records.aggregate(total=Sum('flight_duration'))['total']
    
    # Format the duration for display
    total_flight_time = "0:00"
    if total_duration:
        total_seconds = int(total_duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        total_flight_time = f"{hours}:{minutes:02d}"
    
    context = {
        'training_records': training_records[:10],  # Latest 10 records
        'pending_records': pending_records,
        'total_flights': total_flights,
        'solo_flights_count': solo_flights_count,
        'signed_off_count': signed_off_count,
        'total_flight_time': total_flight_time,
    }
    
    return render(request, 'training_records/student_dashboard.html', context)

@login_required
def instructor_dashboard(request):
    if not request.user.is_instructor():
        return HttpResponseForbidden("Instructors only")
    
    # Get recent training records where this user is the instructor
    instructor_records = TrainingRecord.objects.filter(instructor=request.user).order_by('-date')
    
    # Get unsigned records that need attention
    unsigned_records = instructor_records.filter(signed_off=False).order_by('-date')
    
    # Calculate total flights and flight time
    total_flights = instructor_records.count()
    
    # Calculate total flight time
    total_duration = instructor_records.aggregate(total=Sum('flight_duration'))['total']
    # Format the duration for display
    total_flight_time = "0:00:00"
    if total_duration:
        total_seconds = int(total_duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60
        total_flight_time = f"{hours}:{minutes:02d}:{seconds:02d}"
    
    # Count of students taught
    students_count = instructor_records.values('student').distinct().count()
    
    # Get all students for the lookup feature
    all_students = User.objects.filter(user_type='student').order_by('first_name', 'last_name')
    
    # Get recent students with training count
    from django.db.models import Count
    
    recent_students = User.objects.filter(
        user_type='student',
        student_records__instructor=request.user
    ).annotate(
        training_count=Count('student_records')
    ).order_by('-student_records__date')[:5]
    
    # Make recent_students distinct
    recent_students = list(dict.fromkeys(recent_students))
    
    context = {
        'instructor_records': instructor_records[:10],  # Latest 10 records
        'unsigned_records': unsigned_records,
        'total_flights': total_flights,
        'total_flight_time': total_flight_time,
        'students_count': students_count,
        'pending_count': unsigned_records.count(),
        'all_students': all_students,
        'recent_students': recent_students,
    }
    
    return render(request, 'training_records/instructor_dashboard.html', context)

# Training Record views
class TrainingRecordListView(LoginRequiredMixin, ListView):
    """List all training records the user has access to"""
    model = TrainingRecord
    template_name = 'training_records/record_list.html'
    context_object_name = 'records'
    paginate_by = 20
    
    def get_queryset(self):
        queryset = TrainingRecord.objects.all().order_by('-date')
        
        # Filter based on user type
        if self.request.user.is_student():
            queryset = queryset.filter(student=self.request.user)
        elif self.request.user.is_instructor():
            # Instructors can see their own records and any unsigned records
            queryset = queryset.filter(
                Q(instructor=self.request.user) | 
                Q(signed_off=False)
            )
        # Admin users can see all records
        
        # Add search functionality
        search_query = self.request.GET.get('q')
        if search_query:
            queryset = queryset.filter(
                Q(student__username__icontains=search_query) |
                Q(instructor__username__icontains=search_query) |
                Q(training_topic__name__icontains=search_query) |
                Q(glider__tail_number__icontains=search_query)
            )
            
        return queryset

class TrainingRecordDetailView(LoginRequiredMixin, DetailView):
    """Detail view for a training record"""
    model = TrainingRecord
    template_name = 'training_records/record_detail.html'
    context_object_name = 'record'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['can_sign'] = (
            self.request.user.is_instructor() and 
            self.object.instructor == self.request.user and
            not self.object.signed_off
        )

        # Format the duration as HH:MM
        duration = self.object.flight_duration
        if duration:
            total_seconds = int(duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            context['formatted_duration'] = f"{hours}:{minutes:02d}"
        else:
            context['formatted_duration'] = "0:00"

        # Filter exercises by category
        context['pre_solo_exercises'] = self.object.exercises.filter(category='pre-solo')
        context['post_solo_exercises'] = self.object.exercises.filter(category='post-solo')

        return context

# Update in training_records/views.py

class TrainingRecordCreateView(LoginRequiredMixin, CreateView):
    """Create a new training record"""
    model = TrainingRecord
    form_class = TrainingRecordForm
    template_name = 'training_records/record_form.html'
    success_url = reverse_lazy('record_list')
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Add split exercises lists to context
        context['all_pre_solo_exercises'] = Exercise.objects.filter(category='pre-solo').order_by('number', 'name')
        context['all_post_solo_exercises'] = Exercise.objects.filter(category='post-solo').order_by('number', 'name')
        
        return context
    
    def form_valid(self, form):
        # Set the student to the current user if they're a student
        if self.request.user.is_student():
            form.instance.student = self.request.user
        
        messages.success(self.request, 'Training record created successfully.')
        return super().form_valid(form)

class TrainingRecordUpdateView(LoginRequiredMixin, UpdateView):
    """Update an existing training record"""
    model = TrainingRecord
    form_class = TrainingRecordForm
    template_name = 'training_records/record_form.html'
    
    def get_success_url(self):
        return reverse_lazy('record_detail', kwargs={'pk': self.object.pk})
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Add split exercises lists to context
        context['all_pre_solo_exercises'] = Exercise.objects.filter(category='pre-solo').order_by('number', 'name')
        context['all_post_solo_exercises'] = Exercise.objects.filter(category='post-solo').order_by('number', 'name')
        
        return context
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # Students can only edit unsigned records they're part of
        if self.request.user.is_student():
            return queryset.filter(student=self.request.user, signed_off=False)
        
        # Instructors can edit any record they instructed
        if self.request.user.is_instructor():
            return queryset.filter(instructor=self.request.user)
        
        # Admins can edit any record
        return queryset

# Profile management views
@login_required
def profile_view(request):
    """View user profile details"""
    return render(request, 'training_records/profile.html', {'user': request.user})

@login_required
def profile_update(request):
    """
    Update user profile with secure file handling.
    
    Ensures:
    - Only authorized users can update profiles
    - Image validation is performed
    - Old files are cleaned up securely using Django's storage API
    - Transactions prevent partial updates
    """
    if not (request.user.is_student() or request.user.is_instructor()):
        messages.error(request, "Only students and instructors can update their profile information.")
        return redirect('profile')
    
    if request.method == 'POST':
        # Get a copy of the user to access old file names through Django's storage API
        old_user = User.objects.get(pk=request.user.pk)
        
        # Store file names only (not paths) using Django's storage methods
        old_license_name = old_user.student_license_photo.name if old_user.student_license_photo else None
        old_medical_name = old_user.student_medical_id_photo.name if old_user.student_medical_id_photo else None
        
        form = ProfileUpdateForm(request.POST, request.FILES, instance=request.user)
        
        if form.is_valid():
            try:
                with transaction.atomic():
                    # Save the form with transaction to ensure atomicity
                    form.save()
                    
                    # Clean up old files if they were replaced using Django's storage API
                    if 'student_license_photo' in request.FILES and old_license_name:
                        # Get the new name
                        new_license_name = request.user.student_license_photo.name
                        
                        # Only delete if the file names are different
                        if old_license_name != new_license_name:
                            try:
                                # Use default_storage to safely delete the file
                                if default_storage.exists(old_license_name):
                                    default_storage.delete(old_license_name)
                            except Exception as e:
                                # Log error but continue - file cleanup isn't critical
                                logger.warning(f"Could not remove old license photo: {e}")
                    
                    if 'student_medical_id_photo' in request.FILES and old_medical_name:
                        # Get the new name
                        new_medical_name = request.user.student_medical_id_photo.name
                        
                        # Only delete if the file names are different
                        if old_medical_name != new_medical_name:
                            try:
                                # Use default_storage to safely delete the file
                                if default_storage.exists(old_medical_name):
                                    default_storage.delete(old_medical_name)
                            except Exception as e:
                                # Log error but continue - file cleanup isn't critical
                                logger.warning(f"Could not remove old medical ID photo: {e}")
                
                messages.success(request, "Your profile has been updated successfully.")
                return redirect('profile')
                
            except Exception as e:
                logger.error(f"Error updating profile for user {request.user.id}: {str(e)}")
                messages.error(request, "An error occurred while updating your profile. Please try again.")
    else:
        form = ProfileUpdateForm(instance=request.user)
    
    return render(request, 'training_records/profile_update.html', {'form': form})


# Password change views
@login_required
def change_password(request):
    """Standard password change view"""
    if request.method == 'POST':
        form = PasswordChangeForm(request.user, request.POST)
        if form.is_valid():
            user = form.save()
            # Update the session to prevent logging out
            update_session_auth_hash(request, user)
            messages.success(request, "Your password was successfully updated!")
            return redirect('dashboard')
    else:
        form = PasswordChangeForm(request.user)
    
    return render(request, 'training_records/change_password.html', {'form': form})


@login_required
def first_login_password_change(request):
    if not request.user.password_change_required:
        return redirect('dashboard')

    if request.method == 'POST':
        form = PasswordChangeRequiredForm(request.POST)
        if form.is_valid():
            password = form.cleaned_data['new_password1']
            
            # Validate password against your configured validators
            try:
                validate_password(password, request.user)
                
                # If validation passes, set the password
                request.user.set_password(password)
                request.user.password_change_required = False
                request.user.save()
                
                # Update session
                update_session_auth_hash(request, request.user)
                
                messages.success(request, "Your password has been changed successfully. You can now access the system.")
                return redirect('dashboard')
                
            except ValidationError as error:
                # Add validation errors to the form
                form.add_error('new_password1', error)
    else:
        form = PasswordChangeRequiredForm()

    return render(request, 'training_records/first_login.html', {'form': form})

# Sign-off functionality
@login_required
def sign_record(request, pk):
    """Allow instructors to sign off on a training record"""
    record = get_object_or_404(TrainingRecord, pk=pk)
    
    # Only the instructor assigned to the record can sign it off
    if not request.user.is_instructor() or request.user != record.instructor:
        return HttpResponseForbidden("You are not authorized to sign off this record.")
    
    # Can't sign off a record that's already signed
    if record.signed_off:
        messages.warning(request, "This record has already been signed off.")
        return redirect('record_detail', pk=record.pk)
    
    if request.method == 'POST':
        form = SignOffForm(request.POST)
        if form.is_valid():
            # Perform the sign-off
            instructor_comments = form.cleaned_data['instructor_comments']
            internal_comments = form.cleaned_data['internal_comments']

            # Update record with comments
            if instructor_comments:
                record.instructor_comments = instructor_comments
            if internal_comments:
                record.internal_comments = internal_comments


            record.sign(request.user)
            record.save()
            # Create a log entry (this is already handled by our signal handler)
            messages.success(request, f"Training record #{record.pk} has been successfully signed off.")
            return redirect('record_detail', pk=record.pk)
    else:
        form = SignOffForm(initial={
            'instructor_comments': record.instructor_comments,
            'internal_comments': record.internal_comments
        })
    
    return render(request, 'training_records/sign_record.html', {
        'form': form,
        'record': record
    })
@login_required
def student_history(request, student_id):
    # Check if user is an instructor
    if not request.user.is_instructor():
        return HttpResponseForbidden("Only instructors can view student histories")
    
    # Get the student
    student = get_object_or_404(User, pk=student_id, user_type='student')
    
    # Get all training records for this student (regardless of instructor)
    training_records = TrainingRecord.objects.filter(student=student).order_by('-date')
    
    # Calculate statistics
    total_flights = training_records.count()
    solo_flights = training_records.filter(is_solo=True).count()
    signed_off_count = training_records.filter(signed_off=True).count()
    
    # Calculate total flight time
    total_duration = training_records.aggregate(total=Sum('flight_duration'))['total']
    # Format the duration for display
    total_flight_time = "0:00"
    if total_duration:
        total_seconds = int(total_duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        total_flight_time = f"{hours}:{minutes:02d}"
    
    # Get all exercises completed by the student
    completed_exercises = Exercise.objects.filter(
        training_records__student=student,
        training_records__signed_off=True
    ).distinct()
    
    # Get pre-solo and post-solo exercises separately
    pre_solo_exercises = completed_exercises.filter(category='pre-solo')
    post_solo_exercises = completed_exercises.filter(category='post-solo')
    
    # Find all instructors who worked with this student
    instructors = User.objects.filter(
        instructor_records__student=student
    ).distinct()
    
    context = {
        'student': student,
        'training_records': training_records,
        'total_flights': total_flights,
        'solo_flights': solo_flights,
        'signed_off_count': signed_off_count,
        'total_flight_time': total_flight_time,
        'pre_solo_exercises': pre_solo_exercises,
        'post_solo_exercises': post_solo_exercises,
        'instructors': instructors,
    }
    
    return render(request, 'training_records/student_history.html', context)


@login_required
def student_lookup(request):
    # Check if user is an instructor
    if not request.user.is_instructor():
        return HttpResponseForbidden("Only instructors can look up students")
    
    # If a student ID is provided, redirect to the student history page
    student_id = request.GET.get('student_id')
    if student_id:
        return redirect('student_history', student_id=student_id)
    
    # Get all students for the lookup form
    all_students = User.objects.filter(user_type='student').order_by('first_name', 'last_name')
    
    # Get recent records for quick access
    recent_records = TrainingRecord.objects.all().order_by('-date')[:20]
    
    # Group students with their most recent training topic
    from django.db.models import Max
    
    students_with_recent_activity = User.objects.filter(
        user_type='student',
        student_records__isnull=False
    ).annotate(
        last_training_date=Max('student_records__date')
    ).order_by('-last_training_date')[:15]
    
    # Get the most recent training topic for each student
    for student in students_with_recent_activity:
        recent_record = TrainingRecord.objects.filter(
            student=student
        ).order_by('-date').first()
        
        if recent_record:
            student.recent_topic = recent_record.training_topic.name
            student.recent_date = recent_record.date
    
    context = {
        'all_students': all_students,
        'students_with_recent_activity': students_with_recent_activity,
        'recent_records': recent_records,
    }
    
    return render(request, 'training_records/student_lookup.html', context)


# Replace your current export functions with these more robust versions

@login_required
def export_student_records(request, student_id, format='pdf'):
    """
    Export a student's training records as either PDF or CSV with improved error handling.
    """
    try:
        # Check permissions - only instructors or the student themselves can export
        if not (request.user.is_instructor() or request.user.id == int(student_id)):
            return HttpResponseForbidden("You don't have permission to export these records.")
        
        # Get the student
        student = get_object_or_404(User, id=student_id, user_type='student')
        
        # Get all records for this student, ordered by date
        records = TrainingRecord.objects.filter(
            student=student
        ).order_by('date')
        
        # Check if any records exist
        if not records.exists():
            messages.warning(request, "No training records found to export.")
            return redirect('record_list')
        
        if format.lower() == 'csv':
            return _export_csv(student, records)
        else:  # Default to PDF
            return _export_pdf(student, records)
    
    except Exception as e:
        # Log the detailed error with traceback
        import traceback
        logger.error(f"Error exporting records: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Show a user-friendly message
        messages.error(request, f"An error occurred while exporting records: {str(e)}")
        return redirect('record_list')
def _export_csv(student, records):
    """Generate a CSV export of student training records with proper UTF-8 encoding."""
    try:
        response = HttpResponse(
            content_type='text/csv; charset=utf-8',
            headers={'Content-Disposition': f'attachment; filename="{student.username}_training_records.csv"'},
        )
        
        # Add BOM (Byte Order Mark) for Excel to recognize UTF-8
        response.write('\ufeff')
        
        writer = csv.writer(response)
        
        # Write header row
        writer.writerow([
            'Flight Number', 'Date', 'Topic', 'Glider', 'Location', 'Instructor',
            'Tow Height', 'Duration', 'Solo Flight', 'Student Comments', 
            'Instructor Comments', 'Signed Off', 'Sign Off Date'
        ])
        
        # Write data rows with robust error handling and proper UTF-8 encoding
        for record in records:
            # Handle potentially None values safely
            flight_number = record.get_flight_number() or ""
            date = record.date.strftime('%Y-%m-%d') if record.date else ""
            topic = record.training_topic.name if record.training_topic else ""
            glider = f"{record.glider.tail_number} ({record.glider.model})" if record.glider else ""
            location = record.field or ""
            
            # Handle instructor carefully
            if record.is_solo:
                instructor = "Solo Flight"
            else:
                instructor = record.instructor.get_full_name() if record.instructor else "Unknown"
            
            # Handle other fields
            tow_height = f"{record.tow_height} ft" if record.tow_height else ""
            duration = str(record.flight_duration) if record.flight_duration else ""
            solo = "Yes" if record.is_solo else "No"
            
            # Ensure text fields are properly handled as UTF-8
            student_comments = record.student_comments or ""
            instructor_comments = record.instructor_comments or ""
            signed_off = "Approved" if record.signed_off else "Not Approved"
            
            # Format timestamp carefully
            sign_off_date = ""
            if record.sign_off_timestamp:
                try:
                    sign_off_date = record.sign_off_timestamp.strftime('%Y-%m-%d %H:%M')
                except:
                    sign_off_date = str(record.sign_off_timestamp)
            
            # Write the row with safe values
            writer.writerow([
                flight_number, date, topic, glider, location, instructor,
                tow_height, duration, solo, student_comments,
                instructor_comments, signed_off, sign_off_date
            ])
        
        return response
    except Exception as e:
        # Log the error for debugging
        import traceback
        logger.error(f"CSV export error: {str(e)}")
        logger.error(traceback.format_exc())
        raise

def _export_pdf(student, records):
    """Generate a professional PDF export with improved layout and RTL support."""
    try:
        buffer = BytesIO()
        
        # Define the hebrew character pattern at the beginning for reuse
        import re
        hebrew_char_pattern = re.compile(r'[\u0590-\u05FF\uFB1D-\uFB4F]')
        
        # Load fonts with proper RTL/Hebrew support
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        import os
        from django.conf import settings
        
        # Register fonts - first look in common locations
        font_paths = [
            os.path.join(settings.BASE_DIR, 'static', 'fonts', 'NotoSansHebrew-Regular.ttf'),
            os.path.join(settings.BASE_DIR, 'static', 'fonts', 'DejaVuSans.ttf'),
            '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',  # Linux common location
            os.path.join(settings.BASE_DIR, 'DejaVuSans.ttf'),
        ]
        
        hebrew_font_found = False
        for path in font_paths:
            if os.path.exists(path):
                try:
                    font_name = os.path.basename(path).split('.')[0]
                    pdfmetrics.registerFont(TTFont(font_name, path))
                    hebrew_font_found = True
                    logger.info(f"Using font: {font_name} from {path}")
                    break
                except Exception as e:
                    logger.warning(f"Could not register font {path}: {e}")
        
        if not hebrew_font_found:
            logger.warning("No Hebrew-compatible font found, using default fonts")
            font_name = 'Helvetica'
        
        # Set up the document with a more professional layout
        from reportlab.lib.pagesizes import A4
        from reportlab.lib.units import cm
        
        # Use A4 instead of letter for international standard
        doc = SimpleDocTemplate(
            buffer,
            pagesize=A4,
            rightMargin=1.5*cm,
            leftMargin=1.5*cm,
            topMargin=2*cm,
            bottomMargin=2*cm
        )
        
        # Define styles with improved typography
        styles = getSampleStyleSheet()
        
        # Set up custom styles with our font
        if hebrew_font_found:
            title_style = ParagraphStyle(
                'HebrewTitle',
                parent=styles['Title'],
                fontName=font_name,
                fontSize=16,
                alignment=1,  # Center alignment
                spaceAfter=0.5*cm
            )
            
            heading_style = ParagraphStyle(
                'HebrewHeading',
                parent=styles['Heading2'],
                fontName=font_name,
                fontSize=14, 
                alignment=1,  # Center alignment
                spaceAfter=0.3*cm
            )
            
            normal_style = ParagraphStyle(
                'HebrewNormal',
                parent=styles['Normal'],
                fontName=font_name,
                fontSize=10,
                alignment=2,  # Right alignment for RTL text
                leading=14
            )
            
            cell_style = ParagraphStyle(
                'HebrewCell',
                parent=normal_style,
                fontSize=9,
                leading=12,
                alignment=2  # Right alignment for RTL text
            )
            
            cell_style_left = ParagraphStyle(
                'HebrewCellLeft',
                parent=cell_style,
                alignment=0  # Left alignment
            )
            
            header_style = ParagraphStyle(
                'HebrewHeader',
                parent=cell_style,
                fontSize=9,
                leading=12,
                fontName=font_name,
                textColor=colors.white,
                alignment=1  # Center alignment
            )
        else:
            # Use default styles if Hebrew fonts not available
            title_style = styles['Title']
            heading_style = styles['Heading2']
            normal_style = styles['Normal']
            cell_style = ParagraphStyle(
                'Cell',
                parent=normal_style,
                fontSize=9,
                leading=12
            )
            cell_style_left = ParagraphStyle(
                'CellLeft',
                parent=cell_style,
                alignment=0
            )
            header_style = ParagraphStyle(
                'Header',
                parent=cell_style,
                textColor=colors.white,
                alignment=1
            )
        
        # Create a dictionary of Hebrew labels - expanded with more professional labels
        hebrew_labels = {
            'Training Record for': 'רשומת אימון עבור',
            'Training Topic': 'נושא הדרכה',
            'Flight Number': 'מספר טיסה',
            'Date': 'תאריך',
            'Glider': 'דאון',
            'Field/Location': 'שדה/מיקום',
            'Instructor': 'מדריך',
            'Tow Height': 'גובה גרירה',
            'Flight Duration': 'משך טיסה',
            'Solo Flight': 'טיסת סולו',
            'Student Comments': 'הערות חניך',
            'Instructor Comments': 'הערות מדריך',
            'License Number': 'מספר רישיון',
            'Status': 'סטטוס',
            'Signed Off Date': 'תאריך אישור',
            'Flight Information': 'פרטי טיסה',
            'Student Information': 'פרטי חניך',
            'Flight Log': 'יומן טיסות',
            'Not provided': 'לא צוין',
            'Yes': 'כן',
            'No': 'לא',
            'Approved': 'אושר',
            'Pending': 'ממתין',
            'N/A': 'לא זמין',
            'No comments provided.': 'לא נמסרו הערות.',
            'Student': 'חניך',
            'Page': 'עמוד',
            'of': 'מתוך',
            'Training Summary': 'סיכום הדרכה',
            'Total Flights': 'סה"כ טיסות',
            'Total Flight Time': 'סה"כ זמן טיסה',
            'Solo Flights': 'טיסות סולו',
            'Training Report': 'דו"ח אימונים',
            'Generated on': 'הופק בתאריך'
        }
        
        # Helper function for proper RTL text handling
        def fix_rtl_text(text):
            """Handle RTL text properly for PDF rendering using python-bidi for best results."""
            if not text or not isinstance(text, str):
                return ""
                
            # Check if the text contains Hebrew characters
            import re
            hebrew_char_pattern = re.compile(r'[\u0590-\u05FF\uFB1D-\uFB4F]')
            
            if not hebrew_char_pattern.search(text):
                return text
                
            # Use python-bidi for proper bidirectional text handling
            try:
                from bidi.algorithm import get_display
                
                # First, process the text with python-bidi
                processed_text = get_display(text)
                
                # Special handling for HTML entity characters that need to be preserved
                processed_text = processed_text.replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>')
                processed_text = processed_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
                
                return processed_text
            except ImportError:
                # Log a more specific error to encourage installation of python-bidi
                logger.error("python-bidi package is not installed. For proper RTL text handling, install with: pip install python-bidi")
                
                # Fall back to basic RTL handling (existing code)
                pattern = re.compile(r'([\u0590-\u05FF\uFB1D-\uFB4F]+\s*)(\d+)')
                
                def fix_hebrew_with_numbers(match):
                    hebrew_part = match.group(1)
                    number_part = match.group(2)
                    return number_part + " " + hebrew_part[::-1]
                
                # First handle Hebrew with numbers
                text = pattern.sub(fix_hebrew_with_numbers, text)
                
                # Then handle any remaining Hebrew text (without numbers)
                segments = []
                current_text = text
                
                while current_text:
                    match = hebrew_char_pattern.search(current_text)
                    if not match:
                        segments.append(("non-hebrew", current_text))
                        break
                    
                    start = match.start()
                    if start > 0:
                        segments.append(("non-hebrew", current_text[:start]))
                    
                    # Find the end of this Hebrew segment
                    end = start
                    while end < len(current_text) and hebrew_char_pattern.match(current_text[end]):
                        end += 1
                    
                    segments.append(("hebrew", current_text[start:end]))
                    current_text = current_text[end:]
                
                # Process segments appropriately
                result = ""
                for seg_type, seg_text in segments:
                    if seg_type == "hebrew":
                        result += seg_text[::-1]  # Reverse Hebrew characters
                    else:
                        result += seg_text
                
                return result
        
        # Helper function to wrap text in Paragraph objects
        def wrap_text(text, style=cell_style, rtl=True):
            """Create a properly formatted paragraph for the PDF with improved RTL handling."""
            if not text:
                return Paragraph("", style)
                
            # Convert to string and handle special characters
            text_str = str(text)
            text_str = text_str.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
            
            # For longer text that might contain multiple lines, split and process each line
            if rtl and contains_hebrew(text_str) and '\n' in text_str:
                lines = text_str.split('\n')
                rtl_lines = [fix_rtl_text(line) for line in lines]
                text_str = '<br/>'.join(rtl_lines)
            # Process single-line RTL text
            elif rtl and contains_hebrew(text_str):
                text_str = fix_rtl_text(text_str)
                
            return Paragraph(text_str, style)
        
        # Create document content with a more professional structure
        content = []
        
        # Add a header with logo placeholder and title
        # This would be replaced with your actual logo in a real implementation
        from reportlab.platypus import Image, Table
        
        # Get current date in Hebrew-friendly format
        from datetime import datetime
        current_date = datetime.now().strftime('%Y-%m-%d')
        
        # Create header
        header_text = f"{hebrew_labels['Training Report']}: {student.get_full_name()}"
        content.append(Paragraph(fix_rtl_text(header_text), title_style))
        
        # Add student information block
        student_info = [
            [wrap_text(f"{hebrew_labels['Student']}: {student.get_full_name()}", normal_style)],
            [wrap_text(f"{hebrew_labels['License Number']}: {student.student_license_number or hebrew_labels['Not provided']}", normal_style)],
            [wrap_text(f"{hebrew_labels['Generated on']}: {current_date}", normal_style)]
        ]
        
        student_table = Table(student_info, colWidths=[doc.width])
        student_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('BOTTOMPADDING', (0, 0), (0, -1), 6),
            ('TOPPADDING', (0, 0), (0, -1), 6),
        ]))
        content.append(student_table)
        content.append(Spacer(1, 0.5*cm))
        
        # Add a summary section
        total_flights = len(records)
        total_duration = records.aggregate(total=Sum('flight_duration'))['total']
        solo_flights = records.filter(is_solo=True).count()
        
        # Format total flight time
        if total_duration:
            total_seconds = int(total_duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            total_flight_time = f"{hours}:{minutes:02d}"
        else:
            total_flight_time = "0:00"
        
        # Create summary section
        summary_heading = Paragraph(fix_rtl_text(hebrew_labels['Training Summary']), heading_style)
        content.append(summary_heading)
        
        summary_data = [
            [wrap_text(str(total_flights), cell_style_left),
            wrap_text(hebrew_labels['Total Flights'], cell_style)],
            [wrap_text(total_flight_time, cell_style_left),
            wrap_text(hebrew_labels['Total Flight Time'], cell_style)],
            [wrap_text(str(solo_flights), cell_style_left),
            wrap_text(hebrew_labels['Solo Flights'], cell_style)]
        ]

        # Reverse the width percentages to make Hebrew column 30%
        summary_table = Table(summary_data, colWidths=[doc.width * 0.7, doc.width * 0.3])

        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (1, 0), (1, -1), colors.lightgrey),  # Hebrew labels column background
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),  # Right-align numbers (not center)
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),  # Right-align Hebrew text
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('FONTNAME', (0, 0), (-1, -1), font_name if hebrew_font_found else 'Helvetica'),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('DIRECTION', (0, 0), (-1, -1), 'RTL'),
        ]))
        
        content.append(summary_table)
        content.append(Spacer(1, 1*cm))
        
        # Add flight log heading
        flight_log_heading = Paragraph(fix_rtl_text(hebrew_labels['Flight Log']), heading_style)
        content.append(flight_log_heading)
        
        # Process each flight record with a more attractive layout
        for i, record in enumerate(records):
            # Get and format all the record data
            flight_num = record.get_flight_number() if hasattr(record, 'get_flight_number') else i+1
            date_str = record.date.strftime('%Y-%m-%d') if record.date else hebrew_labels['N/A']
            
            topic = record.training_topic.name if record.training_topic else hebrew_labels['N/A']
            glider = f"{record.glider.tail_number} ({record.glider.model})" if record.glider else hebrew_labels['N/A']
            field = record.field or hebrew_labels['N/A']
            
            # Format duration as HH:MM
            if record.flight_duration:
                total_seconds = int(record.flight_duration.total_seconds())
                hours = total_seconds // 3600
                minutes = (total_seconds % 3600) // 60
                duration = f"{hours}:{minutes:02d}"
            else:
                duration = "0:00"
            
            tow_height = f"{record.tow_height} ft" if record.tow_height else hebrew_labels['N/A']
            solo_flight = hebrew_labels['Yes'] if record.is_solo else hebrew_labels['No']
            
            # Get instructor info
            if record.is_solo:
                instructor_name = hebrew_labels['Solo Flight']
            else:
                instructor_name = record.instructor.get_full_name() if record.instructor else "Unknown"
                
            # Get comments
            student_comments = record.student_comments or hebrew_labels['No comments provided.']
            instructor_comments = record.instructor_comments or hebrew_labels['No comments provided.']
            
            # Get approval info
            status = hebrew_labels['Approved'] if record.signed_off else hebrew_labels['Pending']
            sign_date = record.sign_off_timestamp.strftime('%Y-%m-%d %H:%M') if record.signed_off and record.sign_off_timestamp else hebrew_labels['N/A']
            
            # Special fixed handling for flight titles with numbers
            # In the reference image, the format is "מספר טיסה: 1 - 2025-03-03"
            # We need to directly format it to match exactly as shown in the example
            
            # Format the title exactly as shown in the reference image
            # Format the date in DD-MM-YYYY format instead of YYYY-MM-DD
            # Format the date in DD-MM-YYYY format
            if record.date:
                date_str = record.date.strftime('%d-%m-%Y')
            else:
                date_str = hebrew_labels['N/A']

            # Restructure the title for proper RTL display
            # In RTL, we need to reverse the logical order of the elements
            flight_title = f"{hebrew_labels['Flight Number']} : {flight_num} - {date_str}"
           
            # Create table header
            header_data = [
                [wrap_text(flight_title, header_style, rtl=True)]
            ]
            
            header_table = Table(header_data, colWidths=[doc.width])
            header_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, 0), colors.darkblue),
                ('TEXTCOLOR', (0, 0), (0, 0), colors.white),
                ('ALIGN', (0, 0), (0, 0), 'RIGHT'),
                ('VALIGN', (0, 0), (0, 0), 'MIDDLE'),
                ('FONTNAME', (0, 0), (0, 0), font_name if hebrew_font_found else 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (0, 0), 6),
                ('TOPPADDING', (0, 0), (0, 0), 6),
                ('DIRECTION', (0, 0), (0, 0), 'RTL'),  # Set RTL direction
            ]))
            
            # Main flight details - reverse column order for RTL display
            flight_data = [
                # First row - main flight details (reversed column order)
                [wrap_text(instructor_name, cell_style), wrap_text(hebrew_labels['Instructor'], cell_style),
                 wrap_text(topic, cell_style), wrap_text(hebrew_labels['Training Topic'], cell_style)],
                
                # Second row - aircraft details (reversed column order)
                [wrap_text(field, cell_style), wrap_text(hebrew_labels['Field/Location'], cell_style),
                 wrap_text(glider, cell_style), wrap_text(hebrew_labels['Glider'], cell_style)],
                
                # Third row - technical details (reversed column order)
                [wrap_text(duration, cell_style), wrap_text(hebrew_labels['Flight Duration'], cell_style),
                 wrap_text(tow_height, cell_style), wrap_text(hebrew_labels['Tow Height'], cell_style)],

            ]
            
            details_table = Table(flight_data, colWidths=[doc.width * 0.3, doc.width * 0.2, doc.width * 0.3, doc.width * 0.2])
            details_table.setStyle(TableStyle([
                ('BACKGROUND', (1, 0), (1, -1), colors.lightgrey),
                ('BACKGROUND', (3, 0), (3, -1), colors.lightgrey),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('ALIGN', (0, 0), (-1, -1), 'RIGHT'),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, -1), font_name if hebrew_font_found else 'Helvetica'),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('DIRECTION', (0, 0), (-1, -1), 'RTL'),  # Set RTL direction for entire table
            ]))
            
            # Comments section - reverse order for RTL layout
            comment_labels = [
                [wrap_text(hebrew_labels['Instructor Comments'], header_style),
                 wrap_text(hebrew_labels['Student Comments'], header_style)]
            ]
            
            comment_label_table = Table(comment_labels, colWidths=[doc.width * 0.5, doc.width * 0.5])
            comment_label_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.darkblue),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('VALIGN', (0, 0), (-1, 0), 'MIDDLE'),
                ('FONTNAME', (0, 0), (-1, 0), font_name if hebrew_font_found else 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
                ('TOPPADDING', (0, 0), (-1, 0), 6),
                ('DIRECTION', (0, 0), (-1, 0), 'RTL'),  # Set RTL direction
            ]))
            
            comment_data = [
                [wrap_text(instructor_comments, cell_style, rtl=True),
                 Paragraph(fix_rtl_text(student_comments), cell_style)]
            ]
            
            comment_table = Table(comment_data, colWidths=[doc.width * 0.5, doc.width * 0.5])
            comment_table.setStyle(TableStyle([
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('ALIGN', (0, 0), (-1, -1), 'RIGHT'),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('FONTNAME', (0, 0), (-1, -1), font_name if hebrew_font_found else 'Helvetica'),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                ('TOPPADDING', (0, 0), (-1, -1), 6),
                ('LEFTPADDING', (0, 0), (-1, -1), 6),
                ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                ('DIRECTION', (0, 0), (-1, -1), 'RTL'),  # Set RTL direction
            ]))
            
            # Get instructor info for signature (even for solo flights)
            # Get instructor info for signature (even for solo flights)
            instructor_signature_info = ""
            if record.instructor:
                instructor_name = record.instructor.get_full_name() if record.instructor else "Unknown"
                
                # Get license number from whichever field it might be in
                instructor_license = ""
                if hasattr(record.instructor, 'instructor_license_number') and record.instructor.instructor_license_number:
                    instructor_license = record.instructor.instructor_license_number
                elif hasattr(record.instructor, 'license_number') and record.instructor.license_number:
                    instructor_license = record.instructor.license_number
                
                # Create a 4-column table with license number in separate column
                instructor_data = [[
                    wrap_text(instructor_license, cell_style),            # License number
                    wrap_text(hebrew_labels['License Number'], cell_style), # License label
                    wrap_text(instructor_name, cell_style),               # Instructor name
                    wrap_text(hebrew_labels['Instructor'], cell_style)    # Instructor label
                ]]

                instructor_table = Table(instructor_data, colWidths=[doc.width * 0.2, doc.width * 0.3, doc.width * 0.2, doc.width * 0.3])
                instructor_table.setStyle(TableStyle([
                    ('BACKGROUND', (1, 0), (1, 0), colors.lightgrey),  # Background for license label
                    ('BACKGROUND', (3, 0), (3, 0), colors.lightgrey),  # Background for instructor label
                    ('GRID', (0, 0), (3, 0), 0.5, colors.grey),        # Grid for all cells
                    ('ALIGN', (0, 0), (3, 0), 'RIGHT'),                # Right-align all cells
                    ('VALIGN', (0, 0), (3, 0), 'MIDDLE'),
                    ('FONTNAME', (0, 0), (3, 0), font_name if hebrew_font_found else 'Helvetica'),
                    ('BOTTOMPADDING', (0, 0), (3, 0), 6),
                    ('TOPPADDING', (0, 0), (3, 0), 6),
                    ('DIRECTION', (0, 0), (3, 0), 'RTL'),              # RTL direction
                ]))

            # Signature information - keep this the same as before
            signature_color = colors.lightgrey

            signature_data = [[
                wrap_text(sign_date, cell_style_left),  # Value on left
                wrap_text(hebrew_labels['Signed Off Date'], cell_style)  # Label on right
            ]]

            signature_table = Table(signature_data, colWidths=[doc.width * 0.7, doc.width * 0.3])
            signature_table.setStyle(TableStyle([
                ('BACKGROUND', (1, 0), (1, 0), signature_color),  # Background for label cell
                ('GRID', (0, 0), (1, 0), 0.5, colors.grey),  # Grid for both cells
                ('ALIGN', (1, 0), (1, 0), 'RIGHT'),  # Right-align the label
                ('ALIGN', (0, 0), (0, 0), 'RIGHT'),  # Right-align the value
                ('VALIGN', (0, 0), (1, 0), 'MIDDLE'),
                ('FONTNAME', (0, 0), (1, 0), font_name if hebrew_font_found else 'Helvetica'),
                ('BOTTOMPADDING', (0, 0), (1, 0), 6),
                ('TOPPADDING', (0, 0), (1, 0), 6),
                ('DIRECTION', (0, 0), (1, 0), 'RTL'),  # RTL direction
            ]))


            # Add all components of this record
            content.append(header_table)
            content.append(details_table)
            content.append(comment_label_table)
            content.append(comment_table)
            content.append(instructor_table)  # Add the instructor info table first
            content.append(signature_table)
            
            # Add space between records
            if i < len(records) - 1:
                content.append(Spacer(1, 0.8*cm))
        
        # Create a function to add page numbers
        def add_page_numbers(canvas, doc):
            canvas.saveState()
            canvas.setFont(font_name if hebrew_font_found else 'Helvetica', 8)
            
            # Draw the page number at the bottom of each page
            page_num = canvas.getPageNumber()
            text = f"{hebrew_labels['Page']} {page_num}"
            
            # Calculate center of page
            canvas.drawRightString(doc.pagesize[0] - doc.rightMargin, doc.bottomMargin/2, fix_rtl_text(text))
            
            canvas.restoreState()
        
        # Build the PDF with page numbers
        doc.build(content, onFirstPage=add_page_numbers, onLaterPages=add_page_numbers)
        buffer.seek(0)
        
        # Return the PDF as a response
        return FileResponse(
            buffer, 
            as_attachment=True, 
            filename=f"{student.username}_training_records.pdf",
            content_type='application/pdf'
        )
    
    except Exception as e:
        # Log the error for debugging
        import traceback
        logger.error(f"PDF export error: {str(e)}")
        logger.error(traceback.format_exc())
        raise
    
def contains_hebrew(s):
    """Detect if a string contains Hebrew characters."""
    if not s:
        return False
    import re
    hebrew_pattern = re.compile(r'[\u0590-\u05FF\uFB1D-\uFB4F]')
    return bool(hebrew_pattern.search(s))